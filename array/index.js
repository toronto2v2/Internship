
// масив можна створити двома методами:

let arr = ['tina', 'misha'];                      // ['tina', 'misha']
arr = new Array('tina', 'misha');                   // ['tina', 'misha']



// АЛЕ

arr = [5];                                          // [5]
arr = new Array(5);                                 // [, , , , ,]   <5 empty items>



// Методи масивів:



/*
__________________________________________________________________________________________
|                                                                                        |
|                                   Array.of(...args)                                    |
|________________________________________________________________________________________| */
let of;
// Створює новий масив з певних аргументів. Не має проблем таких як наприклад 'new Array(5)'


const arr2 = Array.of(2);               // [2]
const arr3 = Array.of(2,5,'arr');       // [2,5, 'arr']






/*
__________________________________________________________________________________________
|                                                                                        |
|                         Array.from(arrayLike, mapFn, thisArg)                          |
|________________________________________________________________________________________| */
let from;
// Дозволяє зробити з якогось масивоподібного або ітеративного обєкту(Map, Set) повноцінний масив


// Аргументи:

// === arrayLike - те, що потрібно перетворити в масив
// === mapFn (не обовязковий)  - функція, яка буде визвана для кожного елементу масиву
// === thisArg (не обовязковий) - значення this, яке буде використовуватись в mapFn

Array.from(null);                               // typeerror
Array.from(undefined);                          // typeerror
Array.from('str');                              // ['s', 't', 'r']
Array.from(124);                                // []
Array.from(() => {});                           // []
Array.from(Infinity);                           // []
                                                // все що не ітеративне і не null/undefined повертає пустий масив

const set = new Set();
set.add('some');
set.add('some');
set.add('tina');

const arrFromSetWithFunc = Array.from(set, (item,index) => {                
    return `Value: ${item}, index: ${index}`                    //робимо маніпуляції певні
});
arrFromSetWithFunc;                             // [ 'Value: some, index: 0', 'Value: tina, index: 1' ]






/*
__________________________________________________________________________________________
|                                                                                        |
|                                        Array.at(indx)                                  |
|________________________________________________________________________________________| */
let at;

// Дозволяє отримати елемент масиву по індексу. АЛЕ підтримує мінусові значення.

const atArr = ['tina', 'misha'];
atArr.at(-1);                       // 'misha';






/*
__________________________________________________________________________________________
|                                                                                        |
|                      Array.prototype.concat(...value1, valueN)                         |
|________________________________________________________________________________________| */
let concat;

// Повертає новий масив, який складається з масива на якому викликано метод і елементів які передані
// в якості аргументів. Робить ПОВЕРХНЕВУ копію. НЕ ЗМІНЮЄ оригінальний масив

const concatArr1 = ['a', 'b',];
const concatArr2 = ['c', 'd',];
const concatArr3 = ['e', 'f',];

const concatedArr = concatArr1.concat(concatArr2, concatArr3, 5, 'tina', {foo: 'bar'});   // ['a', 'b', 'c', 'd', 'e', 'f', 5, 'tina', {foo: 'bar'}]





/*
__________________________________________________________________________________________
|                                                                                        |
|            Array.prototype.every(callback(item,index,initialArr), thisArg )            |
|________________________________________________________________________________________| */
let every;

// Цей метод перевіряє, чи всі елементи масиву задовільняють умову, передану в callback функцію
// повертає true або false

// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback

const everyarr = [10,20,30,40];

const everyStatus = everyarr.every((item, i, initialArr) => item > 10 ) // false
const everyStatus2 = everyarr.every((item, i, initialArr) => item > 0 ) // true






/*
__________________________________________________________________________________________
|                                                                                        |
|             Array.prototype.some(callback(item,index,initialArr), thisArg )            |
|________________________________________________________________________________________| */
let some;

// Якщо викликається на пустому масиві то в будь якому випадку поверне false

// Метод перевіряє, чи задовільніє хоча б один елемент масиву, умову, яка передана в callback


// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback

const someArr = [1,2,3,4,101,5,76,8];

const someStatus = someArr.some((item, i, initialArr) => {
    console.log('чек');
    return item > 100                                         // якщо хочаб один item > 100, то в someStatus буде true.
})                                                            // як тільки метод поверне true, цикл зупиниться









/*
__________________________________________________________________________________________
|                                                                                        |
|                  Array.prototype.fill(value, start = 0, end = this.length)             |
|________________________________________________________________________________________| */
let fill;

// Дозволяє заповнити масив певним значенням. ЗМІНЮЄ МАСИВ НА ЯКОМУ ВИКЛИКАЄТЬСЯ, А НЕ ПОВЕРТАЄ НОВИЙ

// Аргументи:

//      === value - (обовязковий) - значення, яким потрібно заповнювати масив
//      === start - (не обовязковий) - індекс, з якого потрібно почати заповнювати масив (включно) / 0 за замовчуванням
//      === end   - (не обовязковий) - індекс, на якому потрібно зупинитись заповнювати масив (не включно) / this.length за замовчуванням

const fillArr = ['tina', 'misha', 'ann', 'olya', 'yosyp', 'vasya'];

fillArr.fill('hidden');             // [ 'hidden', 'hidden', 'hidden', 'hidden', 'hidden', 'hidden' ] / без додаткових аргументів замінює все
fillArr.fill('covered', 3);         // [ 'hidden', 'hidden', 'hidden', 'covered', 'covered', 'covered' ] / змінює починаючи з 3 індексу
fillArr.fill('restricted', 3,5);    // [ 'hidden', 'hidden', 'hidden', 'restricted', 'restricted', 'covered' ] / змінює починаючи з 3 індексу і закінчує на 5(не включно)


fillArr.fill({}, 3, 5); // метод заповнює масив ОДНИМ І ТИМ САМИМ ОБЄКТОМ, тобто всі додані обєкти будуть посилатись на один і той самий
fillArr[3].foo = 'bar'; // [ 'hidden', 'hidden', 'hidden', { foo: 'bar' }, { foo: 'bar' }, 'covered' ]


fillArr.fill('changed', 10, 20) // якщо вказати недійсні індекси, то нічого не відбудеться
fillArr.fill('same', 2, 2) // якщо вказати однакові індекси початку і кінця, то нічого не відбудеться
fillArr.fill('same', 2, 3) // [ 'hidden', 'hidden', 'same', { foo: 'bar' }, { foo: 'bar' }, 'covered' ]


Array(3).fill(4);                // [4, 4, 4]






/*
__________________________________________________________________________________________
|                                                                                        |
|             Array.prototype.filter(callback(item,index,initialArr), thisArg)           |
|________________________________________________________________________________________| */
let filter;

// Метод повертає НОВИЙ масив зі всіма елементами, які пройшли перевірку задану в callback


// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку(якщо з неї повернеся true, то item буде доданий в новий масив, false - не буде доданий)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback


const filterArr = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const filteredArr = filterArr.filter((item,i,initialArr) => {           // [ 'exuberant', 'destruction', 'present' ]
    if(item.length > 6) return true
});








/*
__________________________________________________________________________________________
|                                                                                        |
|             Array.prototype.find(callback(item,index,initialArr), thisArg)             |
|________________________________________________________________________________________| */
let find;

// Метод повертає ЗНАЧЕННЯ ПЕРШОГО знайденого елементу, яке підходить по умові, переданій в callback.
// якщо не знаходить то повертає UNDEFINED

// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку(якщо з неї повернеся true, то .find поверне значення item , false - пропустить)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback

const findArrUsers = [
    {name: 'misha', age: 24, hobby: 'programming'},
    {name: 'tina', age: 23, hobby: 'drawing'},
    {name: 'mark', age: 23, hobby: 'computer games'},
    {name: 'ann', age: 13, hobby: 'N/A'},
];

const findMisha = findArrUsers.find((item, i, initialArr) => {          // знайшло користувача 'misha' і повернуло ЦІЛИЙ обєкт, зупинило цикл
    if(item.name === 'misha') return true
});





/*
__________________________________________________________________________________________
|                                                                                        |
|           Array.prototype.findIndex(callback(item,index,initialArr), thisArg)          |
|________________________________________________________________________________________| */
let findIndex;

// Метод повертає ІНДЕКС ПЕРШОГО знайденого елементу, яке підходить по умові, переданій в callback.
// якщо не знаходить то повертає -1   !!!!!!!!


// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку(якщо з неї повернеся true, то .find поверне індекс item , false - пропустить)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback


const findIndexArrUsers = [
    {name: 'tina', age: 23, hobby: 'drawing'},
    {name: 'misha', age: 24, hobby: 'programming'},
    {name: 'mark', age: 23, hobby: 'computer games'},
    {name: 'ann', age: 13, hobby: 'N/A'},
];

const findIndexMisha = findIndexArrUsers.findIndex((item, i, initialArr) => {          // 1 // знайшло користувача 'misha' і повернуло ІНДЕКС ОБЄКТА, зупинило цикл
    if(item.name === 'misha') return true                                              // якщо не знаходить поверне -1
});




/*
__________________________________________________________________________________________
|                                                                                        |
|                   Array.prototype.includes(searchElement, fromIndex = 0)               |
|________________________________________________________________________________________| */
let includes;

// Метод перевіряє чи є певний елемент в масиві. Повертає true або false.

// Аргументи:
// === searchElement - (обовязковий) - елемент який шукаємо 
// === fromIndex     - (не обовязковий) - індекс в масиві з якого почнемо пошуки(включно) / default = 0
//                   - якщо fromIndex більший за довжину масиву, то одразу повернеться false
//                   - fromIndex підтримує мінусові числа. Вираховується за формулою arr.length + (-index) 
//                   - якщо в результаті розрахунків число вийшло менше нуля, то пошук відбуватиметься по всьому масиву

const icludesArr = ['misha', 'tina', 'ann', 'viktor', 'mark', 'sania'];

const includesStatus = icludesArr.includes('ann', -3);          // false

const includesStatus2 = icludesArr.includes('tina', -100);      // true