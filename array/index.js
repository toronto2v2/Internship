
// масив можна створити двома методами:

let arr = ['tina', 'misha'];                      // ['tina', 'misha']
arr = new Array('tina', 'misha');                   // ['tina', 'misha']



// АЛЕ

arr = [5];                                          // [5]
arr = new Array(5);                                 // [, , , , ,]   <5 empty items>



// Методи масивів:

/*
__________________________________________________________________________________________
|                                                                                        |
|                                   Array.of(...args)                                    |
|________________________________________________________________________________________| */
let of;
// Створює новий масив з певних ЗНАЧЕНЬ. Не має проблем таких як наприклад 'new Array(5)'


const arr2 = Array.of(2);               // [2]
const arr3 = Array.of(2,5,'arr');       // [2,5, 'arr']





/*
__________________________________________________________________________________________
|                                                                                        |
|                                   Array.isArray(array)                                 |
|________________________________________________________________________________________| */
let isArray;

// Метод поверне true, якщо переданий аргумент дійсно масив, інахше - false;

Array.isArray([]);                  // true
Array.isArray([1]);                 // true
Array.isArray(new Array());         // true
Array.isArray(Array.prototype);     // true
                                    // все інше - false
//








/*
__________________________________________________________________________________________
|                                                                                        |
|                         Array.from(arrayLike, mapFn, thisArg)                          |
|________________________________________________________________________________________| */
let from;
// Дозволяє зробити з якогось МАСИВОПОДІБНОГО або ІТЕРАТИВНОГО обєкту(Map, Set) повноцінний масив


// Аргументи:

// === arrayLike - те, що потрібно перетворити в масив
// === mapFn (не обовязковий)  - функція, яка буде визвана для кожного елементу масиву. Приймає 2 аргументи: (item, index)
// === thisArg (не обовязковий) - значення this, яке буде використовуватись в mapFn

Array.from(null);                               // typeerror
Array.from(undefined);                          // typeerror
Array.from('str');                              // ['s', 't', 'r']
Array.from(124);                                // []
Array.from(() => {});                           // []
Array.from(Infinity);                           // []
                                                // все що не ітеративне і не null/undefined повертає пустий масив

const set = new Set();
set.add('some');
set.add('some');
set.add('tina');

const arrFromSetWithFunc = Array.from(set, (item,index) => {                
    return `Value: ${item}, index: ${index}`                    //робимо маніпуляції певні
});
arrFromSetWithFunc;                             // [ 'Value: some, index: 0', 'Value: tina, index: 1' ]











/*
__________________________________________________________________________________________
|                                                                                        |
|                                        Array.at(indx)                                  |
|________________________________________________________________________________________| */
let at;

// Дозволяє отримати елемент масиву по індексу. АЛЕ підтримує мінусові значення.

const atArr = ['tina', 'misha'];
atArr.at(-1);                       // 'misha';






/*
__________________________________________________________________________________________
|                                                                                        |
|                      Array.prototype.concat(...value1, valueN)                         |
|________________________________________________________________________________________| */
let concat;

// Повертає новий масив, який складається з масива на якому викликано метод і елементів які передані
// в якості аргументів. Робить ПОВЕРХНЕВУ копію. НЕ ЗМІНЮЄ оригінальний масив

const concatArr1 = ['a', 'b',];
const concatArr2 = ['c', 'd',];
const concatArr3 = ['e', 'f',];

const concatedArr = concatArr1.concat(concatArr2, concatArr3, 5, 'tina', {foo: 'bar'});   // ['a', 'b', 'c', 'd', 'e', 'f', 5, 'tina', {foo: 'bar'}]




/*
__________________________________________________________________________________________
|                                                                                        |
|            Array.prototype.every(callback(item,index,initialArr), thisArg )            |
|________________________________________________________________________________________| */
let every;

// Цей метод перевіряє, чи всі елементи масиву задовільняють умову, передану в callback функцію
// повертає true або false

// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback

const everyarr = [10,20,30,40];

const everyStatus = everyarr.every((item, i, initialArr) => item > 10 ) // false
const everyStatus2 = everyarr.every((item, i, initialArr) => item > 0 ) // true






/*
__________________________________________________________________________________________
|                                                                                        |
|             Array.prototype.some(callback(item,index,initialArr), thisArg )            |
|________________________________________________________________________________________| */
let some;

// Якщо викликається на пустому масиві то в будь якому випадку поверне false

// Метод перевіряє, чи задовільніє хоча б один елемент масиву, умову, яка передана в callback


// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback

const someArr = [1,2,3,4,101,5,76,8];

const someStatus = someArr.some((item, i, initialArr) => {
    console.log('чек');
    return item > 100                                         // якщо хочаб один item > 100, то в someStatus буде true.
})                                                            // як тільки метод поверне true, цикл зупиниться









/*
__________________________________________________________________________________________
|                                                                                        |
|                  Array.prototype.fill(value, start = 0, end = this.length)             |
|________________________________________________________________________________________| */
let fill;

// Дозволяє заповнити масив певним значенням. ЗМІНЮЄ МАСИВ НА ЯКОМУ ВИКЛИКАЄТЬСЯ, А НЕ ПОВЕРТАЄ НОВИЙ

// Аргументи:

//      === value - (обовязковий) - значення, яким потрібно заповнювати масив
//      === start - (не обовязковий) - індекс, з якого потрібно почати заповнювати масив (включно) / 0 за замовчуванням
//      === end   - (не обовязковий) - індекс, на якому потрібно зупинитись заповнювати масив (не включно) / this.length за замовчуванням

const fillArr = ['tina', 'misha', 'ann', 'olya', 'yosyp', 'vasya'];

fillArr.fill('hidden');             // [ 'hidden', 'hidden', 'hidden', 'hidden', 'hidden', 'hidden' ] / без додаткових аргументів замінює все
fillArr.fill('covered', 3);         // [ 'hidden', 'hidden', 'hidden', 'covered', 'covered', 'covered' ] / змінює починаючи з 3 індексу
fillArr.fill('restricted', 3,5);    // [ 'hidden', 'hidden', 'hidden', 'restricted', 'restricted', 'covered' ] / змінює починаючи з 3 індексу і закінчує на 5(не включно)


fillArr.fill({}, 3, 5); // метод заповнює масив ОДНИМ І ТИМ САМИМ ОБЄКТОМ, тобто всі додані обєкти будуть посилатись на один і той самий
fillArr[3].foo = 'bar'; // [ 'hidden', 'hidden', 'hidden', { foo: 'bar' }, { foo: 'bar' }, 'covered' ]


fillArr.fill('changed', 10, 20) // якщо вказати недійсні індекси, то нічого не відбудеться
fillArr.fill('same', 2, 2) // якщо вказати однакові індекси початку і кінця, то нічого не відбудеться
fillArr.fill('same', 2, 3) // [ 'hidden', 'hidden', 'same', { foo: 'bar' }, { foo: 'bar' }, 'covered' ]


Array(3).fill(4);                // [4, 4, 4]






/*
__________________________________________________________________________________________
|                                                                                        |
|             Array.prototype.filter(callback(item,index,initialArr), thisArg)           |
|________________________________________________________________________________________| */
let filter;

// Метод повертає НОВИЙ масив зі всіма елементами, які пройшли перевірку задану в callback


// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку(якщо з неї повернеся true, то item буде доданий в новий масив, false - не буде доданий)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback


const filterArr = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const filteredArr = filterArr.filter((item,i,initialArr) => {           // [ 'exuberant', 'destruction', 'present' ]
    if(item.length > 6) return true
});








/*
__________________________________________________________________________________________
|                                                                                        |
|             Array.prototype.find(callback(item,index,initialArr), thisArg)             |
|________________________________________________________________________________________| */
let find;

// Метод повертає ЗНАЧЕННЯ ПЕРШОГО знайденого елементу, яке підходить по умові, переданій в callback.
// якщо не знаходить то повертає UNDEFINED

// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку(якщо з неї повернеся true, то .find поверне значення item , false - пропустить)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback

const findArrUsers = [
    {name: 'misha', age: 24, hobby: 'programming'},
    {name: 'tina', age: 23, hobby: 'drawing'},
    {name: 'mark', age: 23, hobby: 'computer games'},
    {name: 'ann', age: 13, hobby: 'N/A'},
];

const findMisha = findArrUsers.find((item, i, initialArr) => {          // знайшло користувача 'misha' і повернуло ЦІЛИЙ обєкт, зупинило цикл
    if(item.name === 'misha') return true
});





/*
__________________________________________________________________________________________
|                                                                                        |
|           Array.prototype.findIndex(callback(item,index,initialArr), thisArg)          |
|________________________________________________________________________________________| */
let findIndex;

// Метод повертає ІНДЕКС ПЕРШОГО знайденого елементу, яке підходить по умові, переданій в callback.
// якщо не знаходить то повертає -1   !!!!!!!!


// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде виконувати перевірку(якщо з неї повернеся true, то .find поверне індекс item , false - пропустить)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback


const findIndexArrUsers = [
    {name: 'tina', age: 23, hobby: 'drawing'},
    {name: 'misha', age: 24, hobby: 'programming'},
    {name: 'mark', age: 23, hobby: 'computer games'},
    {name: 'ann', age: 13, hobby: 'N/A'},
];

const findIndexMisha = findIndexArrUsers.findIndex((item, i, initialArr) => {          // 1 // знайшло користувача 'misha' і повернуло ІНДЕКС ОБЄКТА, зупинило цикл
    if(item.name === 'misha') return true                                              // якщо не знаходить поверне -1
});




/*
__________________________________________________________________________________________
|                                                                                        |
|                   Array.prototype.includes(searchElement, fromIndex = 0)               |
|________________________________________________________________________________________| */
let includess;

// Метод перевіряє чи є певний елемент в масиві. Повертає true або false.

// Аргументи:
// === searchElement - (обовязковий) - елемент який шукаємо 
// === fromIndex     - (не обовязковий) - індекс в масиві з якого почнемо пошуки(включно) / default = 0
//                   - якщо fromIndex більший за довжину масиву, то одразу повернеться false
//                   - fromIndex підтримує мінусові числа. Вираховується за формулою arr.length + (-index) 
//                   - якщо в результаті розрахунків число вийшло менше нуля, то пошук відбуватиметься по всьому масиву

const icludesArr = ['misha', 'tina', 'ann', 'viktor', 'mark', 'sania'];

const includesStatus = icludesArr.includes('ann', -3);          // false

const includesStatus2 = icludesArr.includes('tina', -100);      // true







/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.flat(depth)                             |
|________________________________________________________________________________________| */
let flat;

// Цей метод повертає новий масив, в якому всі вкладені масиви піднімаються на  depth рівнів вверх
// тобто з багатомірних масивів ми можемо зробити один масив одного рівня. Не змінює початковий масив. повертає новий

// Аргументи: 

// === depth (не обововязковий) --   число, на скільки зменшиться багатомірність масиву // default = 1;


const flatArr = [
    "misha",
    "slava",
    ["ann", "olya"],
    "yosup",
    ["mars", "luna", "loki", [12, 45, 123, ["foo", "bar", "baz"]]],
];
const flatedArr1231 = flatArr.flat();     // ['misha','slava','ann','olya','yosup','mars','luna','loki',[ 12, 45, 123, [ 'foo', 'bar', 'baz' ] ]
console.log(flatArr);
const flatedArr1 = flatArr.flat(1);     // ['misha','slava','ann','olya','yosup','mars','luna','loki',[ 12, 45, 123, [ 'foo', 'bar', 'baz' ] ]
const flatedArr2 = flatArr.flat(2);     // ['misha','slava','ann','olya','yosup','mars','luna','loki', 12, 45, 123, [ 'foo', 'bar', 'baz']
const flatedArr3 = flatArr.flat(3);     // ['misha','slava','ann','olya','yosup','mars','luna','loki', 12, 45, 123,  'foo', 'bar', 'baz']
const flatedArr4 = flatArr.flat(null);  // повернеся той самий масив, адже null перетвориться на 0, а розгладити масив на нульовий рівень
                                        //не вийде, тому повернеться той самий масив 
//






/*
__________________________________________________________________________________________
|                                                                                        |
|                    Array.prototype.indexOf(searchElement, fromIndex = 0)               |
|________________________________________________________________________________________| */
let indexOf;

// Метод повертає індекс першого знайденого елементу. Якщо не знаходить то повертає -1; fromIndex за замовч = 0

// Відмінність від .findIndex в тому, що в indexOf вказуємо конкретне значення для пошуку, а в findIndex вказуємо 
// callback, в якому проводимо певні перевірки

// Метод порівнює елемент який шукаєм з елементами в масиві методом строгого порівняння. Тобто такі значення як 
// undefined, null і тд не будуть перетворені в рядок

// йде з початку масива в кінець
 
// fromIndex приймає мінусові значення

const indexOfArr = ['zhabka', 'tima', 'biluj', 'kiri', 'undefined','kiri'];

const indexOfPosition = indexOfArr.indexOf('kiri', 3); // fromIndex включно. Поверне 3
const indexOfPosition2 = indexOfArr.indexOf('kiri', 4); // -1
const indexOfPosition3 = indexOfArr.indexOf(['kiri']); // -1        тут строго порівнюється
const indexOfPosition4 = indexOfArr.indexOf(undefined, 4); // -1
const indexOfPosition5 = indexOfArr.indexOf('kiri'); // 3        повертає перший знайдений елемент
const indexOfPosition6 = indexOfArr.indexOf('undefined', -2) // 5 





/*
__________________________________________________________________________________________
|                                                                                        |
|            Array.prototype.lastIndexOf(searchElement, fromIndex = arr.length)          |
|________________________________________________________________________________________| */
let lastIndexOf;
// Метод повертає останній індекс по якому данний елемент може бути знайдений. 
// Якщо не знаходить то повертає -1; fromIndex за замовч = arr.prototype.length

// йде з кінця масиву в початок

// fromIndex ВКЛЮЧНО // 

// Аргументи:
// === searchElement - (обовязковий) - елемент який шукаємо (строге порівняння!!)
// === fromIndex     - (не обовязковий) - За замовчуванням = arr.length. 
//                     якщо вказати мінусові числа, то вони будуть вираховуватись!
//                     тото arr.length + (якесь число)

const lastIndexOfArr = ['zhabka', 'tima', 'biluj', 'kiri', 'undefined','kiri'];


const lastIndexOfPosition = lastIndexOfArr.lastIndexOf('kiri');     // 5
const lastIndexOfPosition2 = lastIndexOfArr.lastIndexOf('kiri', 5);     // 5
const lastIndexOfPosition3 = lastIndexOfArr.lastIndexOf('kiri', 4);     // 3
const lastIndexOfPosition4 = lastIndexOfArr.lastIndexOf('kiri', 3);     // 3
const lastIndexOfPosition5 = lastIndexOfArr.lastIndexOf('kiri', -2);     // 3   замість -2 розрахується : arr.length + (-2) = 4
const lastIndexOfPosition6 = lastIndexOfArr.lastIndexOf('zhabka', -7);     // -1   якщо розрахунок arr.length + (-число) < 0 то одразу повертається -1




/*
__________________________________________________________________________________________
|                                                                                        |
|    Array.prototype.forEach(callback(currentValue, index, initialArray), thisArg)       |
|________________________________________________________________________________________| */
let forEach;

// Метод виконує певну функцію для кожного елементу масиву. Сам по собі нічого не повертає, тобто
// поверне undefined

// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде викликана для кожного елементу масиву
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback


const forEachArr = ['zhabka', 'tima', 'biluj', 'kiri', 'undefined','kiri'];

const copyedArr = [];   // ['zhabka', 'tima', 'biluj', 'kiri', 'undefined','kiri'];

forEachArr.forEach((item, i, initialArr) => copyedArr.push(item))       // просто пушимо кожен айтем з forEachArr в copyedArr





/*
__________________________________________________________________________________________
|                                                                                        |
|    Array.prototype.map(callback(currentValue, index, initialArray), thisArg)           |
|________________________________________________________________________________________| */
let map;

// Метод створює новий масив з результатом виклику callback для кожного елементу масиву.

// Аргументи:
// ====    callback - (обовязковий) - функція, яка буде викликана для кожного елементу масиву (має щось повертати)
//                    ==== callback приймає 3 аргументи:
//                    --- item (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   thisArg - (необовязковий) - значення яке буде використовуватись в якості this в callback


const mapArr = ['zhabka', 'tima', 'biluj', 'kiri', 'undefined','kiri'];

const mappedArr = mapArr.map((item, i, initialArr) => {     
    return `${item}: - done`
});

mappedArr;  // ['zhabka: - done', 'tima: - done', 'biluj: - done', 'kiri: - done', 'undefined: - done','kiri: - done'];







/*
__________________________________________________________________________________________
|                                                                                        |
|  Array.prototype.reduce(callback(acc, nextValue, index, initialArray), initialValue)   |
|________________________________________________________________________________________| */
let reduce;

// Цей метод застосовує функцію reducer для кожного елементу масива (зліва-направо), 
// і повертає одне результуюче значення


// Аргументи:
// ====    callback - (обовязковий) - функція-редюсер, яка буде виконана для кожного елементу
//                    ==== callback приймає 4 аргументи:
//                    --- accumulator - (обовязковий) - акумулятор, в який будуть повертатись всі значення з callback
//                    --- nextValue (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   initialValue - (необовязковий) - значення яке стане acc при першому виклику callback


// Якщо ми не вказуємо акамулятор, то ним стане перший елемент масиву, а nextValue буде другий елемент масиву


const reduceArr = [];

const reducedArr = reduceArr.reduce((acc,next, i, initialArr) => { // якщо пройтись по пустому масиву без  initialValue, то
    return next;                                                   // буде typeError
});
                                                                    // якщо масив пустий а initialValue вказаний, то повернеся
                                                                    // initialValue а callback не буде викликаний
//



/*
__________________________________________________________________________________________
|                                                                                        |
|Array.prototype.reduceRight(callback(acc, nextValue, indx, initialArray), initialValue) |
|________________________________________________________________________________________| */
let reduceRight;


// Цей метод застосовує функцію reducer для кожного елементу масива (зправа-наліво), 
// і повертає одне результуюче значення

// Працює так само як звичайний reduce, але перебирає значення з кінця масиву

// Аргументи:
// ====    callback - (обовязковий) - функція-редюсер, яка буде виконана для кожного елементу
//                    ==== callback приймає 4 аргументи:
//                    --- accumulator - (обовязковий) - акумулятор, в який будуть повертатись всі значення з callback
//                    --- nextValue (обовязковий) - обробляємий елемент масиву
//                    --- index (необовязковий) - індекс обробляємого елементу масиву
//                    --- initialArr (необовязковий) - масив по якому проходимось
// ====   initialValue - (необовязковий) - значення яке стане acc при першому виклику callback



// Якщо ми не вказуємо акамулятор, то ним стане останній елемент масиву, а nextValue буде другий елемент масиву з кінця


const reduceRightArr = [];

const reducedRightArr = reduceArr.reduce((acc,next, i, initialArr) => { // якщо пройтись по пустому масиву без  initialValue, то
    return next;                                                   // буде typeError
});
                                                                    // якщо масив пустий а initialValue вказаний, то повернеся
                                                                    // initialValue а callback не буде викликаний
//




/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.join(separator)                         |
|________________________________________________________________________________________| */
let join;

// Метод дозволяє обєднати всі елементи масиву в рядок, а розділювачем між елементами масиву 
// стане separator

// Аргументи: 
// ====    separator - (не обовязковий) - розділювач, яким будуть розділені елементи масиву в 
//                      рядку ( default = ',')


// якщо масив буде пустий, повернеться пустий рядок


const joinArr = ['water', 'fire', 'wind', 'ground'];

const joinedArr = joinArr.join();           // water,fire,wind,ground
const joinedArr2 = joinArr.join('');        // waterfirewindground
const joinedArr3 = [].join('+');            // ''

// якщо елемент масиву з типом undefined або null, то вони перетворяться в пустий рядок
// але розділювач буде вставлений!!!!!

const joinedArr4 = [12, null, 423, undefined].join('*');            //  12**423*





/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.reverse()                               |
|________________________________________________________________________________________| */
let reverse;

// Мотод розвертає масив. Перший елемент стає останнім, а останній першим. 
// ЗМІНЮЄ МАСИВ НА ЯКОМУ ВИКЛИКАНИЙ

// Аргументів немає

const reverseArr = [1,2,3,,4,5];     // буде змінений 

reverseArr.reverse();               // [ 5, 4,<1 empty item>, 3, 2, 1 ]         

console.log(reverseArr);


/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.toReversed()                            |
|________________________________________________________________________________________| */
let toReversed;

// Метод працює аналогічно Array.prototype.reverse(), але не модифікує початковий масив, а 
// повертає НОВИЙ МАСИВ з зміненим порядком елементів

const toReversedArr = [1,2,3, ,4,5];     // не буде змінений 

const toReversedArrResult = toReversedArr.toReversed();  // [ 5, 4, 3, undefined, 2, 1 ]

console.log(toReversedArrResult);



/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.slice(begin, end)                       |
|________________________________________________________________________________________| */
let slice;

// Повертає новий масив, вміщающий копію початкового масиву. Масиви та обєкти копіює по ПОСИЛАННЮ!!!

// Аргументи:

// ====    begin - (необовязковий) - початковий індекс з якого потрібно почати вирізати
//                  *** якщо він мінусовий, то вказує зміщення відносно кінця послідовності,
//                      виклик slice(-2) виріже останні два елементи послідовності
//                  *** якщо begin не визначений то підставляється 0
//                  *** якщо begin > arr.length, то повернеться пустий масив
//
// ====    end - (необовязковий) - індекс, на якому потрібно закінчити вирізання (не включно)
//                  *** якщо він мінусовий, то вказує зміщення відносно кінця послідовності,
//                      виклик slice(2, -2) виріже елементи з 2(включно) і до 2 з кінця
//                  *** якщо end опущений, то вирізає до кінця послідовності
//
const sliceObj = {foo: 'bar'}
const sliceArr = ['tina', 'misha', sliceObj, 123, ['roboto']];
const slicedArr = sliceArr.slice();              // [ 'tina', 'misha', { foo: 'bar' }, 123, [ 'roboto' ] ]
slicedArr.foo = 'baz';                           // змінивася початковий sliceObj
const slicedArr2 = sliceArr.slice(3);            // [ 123, [ 'roboto' ] ]
const slicedArr3 = sliceArr.slice(-4, -2);       // [ 'misha', { foo: 'baz' } ]
console.log(slicedArr3);




/*
__________________________________________________________________________________________
|                                                                                        |
|          Array.prototype.splice(start, deleteCount, item1, ...itemN)                   |
|________________________________________________________________________________________| */
let splice;

// Змінює початковий масив, видаляючи існуючі елементи або/і додає нові. Якщо присвоїти виклик
// цього методу якійсь змінній, то в змінну потраплять ті елементи, які ми вирізали. А якщо ми
// ще й додамо нові елементи, то вони вставляться в ті позиції, звідки ми вирізали


// Аргументи:
// ====    start - (обовязковий) - індекс з якого потрібно змінити масив. Якщо більше довжини масиву, реальний індекс
//                                  буде встановлений в довжину масиву. Якщо < 0 то відлік почнеться з кінця
// ====   deleteCount - (необовязковий) - кількість елементів які потрібно видалити починаючи з start включно
//                                      Якщо = 0, то нічого не видалиться(якщо вказуємо 0 то потрібно додати хочаб
//                                      один item1). Якщо > кількості елементів починаючи з start, то видалить все до кінця
// ====   itemN - (необовязковий) - елемент який буде доданий до масиву.


// ****************************************************************************************************************************************

const spliceArr = ['tina', 'misha', 'ann', 'sonya']; // змінився початковий масив, додались нові айтеми: [ 'tima', 'mars', 'ann', 'sonya' ]
//                                                          
const removedFromSpliceArr = spliceArr.splice(-4, 2, 'tima', 'mars');   // [ 'tina', 'misha' ] - ті елементи які ми видалили


// ****************************************************************************************************************************************

const spliceArr1 = ['tina', 'misha', 'ann', 'sonya']; //  змінився початковий масив, додались нові айтеми:[ 'tina', 'tima', 'mars', 'lola', 'sonya' ]

const removedFromSpliceArr1 = spliceArr1.splice(1, 2, 'tima', 'mars', 'lola');  // [ 'misha', 'ann' ] - ті елементи які ми видалили


// ****************************************************************************************************************************************


const spliceArr2 = ['tina', 'misha', 'ann', 'sonya']; // []

const removedFromSpliceArr2 = spliceArr1.splice(0);  // ['tina', 'misha', 'ann', 'sonya']


// ****************************************************************************************************************************************

const spliceArr3 = ['tina', 'misha', 'ann', 'sonya']; // ['tina', 'misha', 'ann', 'sonya']

const removedFromSpliceArr3 = spliceArr1.splice();  // []


// ****************************************************************************************************************************************


const spliceArr4 = ['tina', 'misha', 'ann', 'sonya']; // ['tina', 'misha', 'ann', 'sonya']

const removedFromSpliceArr4 = spliceArr4.splice(-3, -2);  // []
console.log(removedFromSpliceArr4);




/*
__________________________________________________________________________________________
|                                                                                        |
|          Array.prototype.toSpliced(start, deleteCount, item1, ...itemN)                |
|________________________________________________________________________________________| */
let toSpliced;

//НЕ ЗМІНЮЄ  початковий масив, видаляє існуючі елементи або/і додає нові. Якщо присвоїти виклик
// цього методу якійсь змінній, то в змінну потрапить НОВИЙ МАСИВ з видаленими і/або доданими елементами

// НЕ ПОВЕРТАЄ ВИДАЛЕНІ ЕЛЕМЕНТИ

const toSplicedArr =  ['tina', 'misha', 'ann', 'sonya']; // НЕ БУДЕ МУТОВАНИЙ

const toSplicedResultedArr = toSplicedArr.toSpliced(-3, 2, 'zhabka', 'dashka', 'hashka' ); // [ 'tina', 'zhabka', 'dashka', 'hashka', 'sonya' ]






/*
__________________________________________________________________________________________
|                                                                                        |
|                           Array.prototype.sort(compareFunction)                        |
|________________________________________________________________________________________| */
let sort;

// Сортує НА МІСЦІ масив(тобто змінить початковий), і повертає відсортований масив. Приймає тільки
// один аргумент compareFunction, який не є обовязковим

// Аргументи: 

// ====    compareFunction - (необовязковий) - Функція, як визначає порядок сортування. Якщо
//                          функцію не вказати, то масив сортується в відповідності до кодовик крапок
//                          юнікод, які отримуються шляхом конвертацію кожного елемента в рядок

// compareFunction має аргументи:
    //  a - перший елемент для порівняння 
    //  b - другий елемент для порівняння
//
// compareFunction має повернути:
//      менше   0  =   в такому випадку a поставиться по меншому індексу ніж b, тобто а іде першим
//              0  =   в такому випадку а і b залишаться незмінними по відношенню один до одного, але
//                     відсортує їх по відношенню до інших елементів.
//      більше  0  =   в такому випадку b поставиться по меншому індексу ніж а, тобто b іде першим

// ****************************************************************************************************************************************

const sortArr = [                               // Цей масив ТАКОЖ БУДЕ ЗМІНЕНО
    { name: 'Edward', value: 21 },
    { name: 'Sharpe', value: 37 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic' },
    { name: 'Zeros', value: 37 }
];

const sortedArr = sortArr.sort((a,b) => a.value - b.value);     // поверне відсортований масив


// ****************************************************************************************************************************************

const sortArr2 = [                               // Цей масив ТАКОЖ БУДЕ ЗМІНЕНО
    { name: 'Edward', value: 21 },
    { name: 'Sharpe', value: 37 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic' },
    { name: 'Zeros', value: 37 }
];

const sortedArr2 = sortArr2.sort((a,b) => {      // відсортує по імені в алфавітному порядку
    if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
});                             

// ****************************************************************************************************************************************





/*
__________________________________________________________________________________________
|                                                                                        |
|                           Array.prototype.toSorted(compareFunction)                    |
|________________________________________________________________________________________| */
let toSorted;
// метод працює так само як  Array.prototype.sort, але не змінює початковий масив, а тільки повертає
// новий відсортований масив


// Аргументи: 

// ====    compareFunction - (необовязковий) - Функція, як визначає порядок сортування. Якщо
//                          функцію не вказати, то масив сортується в відповідності до кодовик крапок
//                          юнікод, які отримуються шляхом конвертацію кожного елемента в рядок

// compareFunction має аргументи:
    //  a - перший елемент для порівняння 
    //  b - другий елемент для порівняння
//
// compareFunction має повернути:
//      менше   0  =   в такому випадку a поставиться по меншому індексу ніж b, тобто а іде першим
//              0  =   в такому випадку а і b залишаться незмінними по відношенню один до одного, але
//                     відсортує їх по відношенню до інших елементів.
//      більше  0  =   в такому випадку b поставиться по меншому індексу ніж а, тобто b іде першим



// ****************************************************************************************************************************************

const toSortedArr = [                               // Цей масив НЕ БУДЕ ЗМІНЕНО
    { name: 'Edward', value: 21 },
    { name: 'Sharpe', value: 37 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic' },
    { name: 'Zeros', value: 37 }
];

const toSortedResArr = toSortedArr.toSorted((a,b) => a.value - b.value);     // поверне відсортований масив



// ****************************************************************************************************************************************

const toSortedArr2 = [                               // Цей масив НЕ БУДЕ ЗМІНЕНО
    { name: 'Edward', value: 21 },
    { name: 'Sharpe', value: 37 },
    { name: 'And', value: 45 },
    { name: 'The', value: -12 },
    { name: 'Magnetic' },
    { name: 'Zeros', value: 37 }
];

const toSortedResArr2 = toSortedArr2.toSorted((a,b) => {      // відсортує по імені в алфавітному порядку
    if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
});                             

// ****************************************************************************************************************************************





/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.toString()                              |
|________________________________________________________________________________________| */
let toString;
// Метод toString в масивах має трохи іншу поведінку. Під капотом він викликає метод .join()
// і обєднує елементи масиву комою. Якщо метод .join() недоступний, то toString() буде взято 
// з Object і в консолі побачимо [object Array]






/*
__________________________________________________________________________________________
|                                                                                        |
|                                Array.prototype.pop()                                   |
|________________________________________________________________________________________| */
let pop;

// Видаляє останній елемент масиву. Якщо присвоюєся змінній, то повертає цей останній елемент.
// якщо викликаний на пустому масиві - поверне undefined


const popArr = ['tina', 'misha', 'zhabka'];    //    ['tina', 'misha']

const poppedValue = popArr.pop();              //    ['zhabka']

// ***************************************************************************************

const popArr2 = [];    //    []

const poppedValue2 = popArr2.pop();              //    undefined



/*
__________________________________________________________________________________________
|                                                                                        |
|                         Array.prototype.push(item1, ...itemN)                          |
|________________________________________________________________________________________| */
let push;
// Додає один або більше елементів в кінецб масиву. Якщо виклик методу присвоєний змінній, то Повертає
// нову довжину масиву


const pushArr = ['tina'];       // ['tina', 'misha', 'zhabka']

const newLength = pushArr.push('misha', 'zhabka');      // 3



/*
__________________________________________________________________________________________
|                                                                                        |
|                                  Array.prototype.shift()                               |
|________________________________________________________________________________________| */
let shift;

// Видаляє перший елемент масиву, змінюючи початковий масив. Якщо виклик методу присвоєний змінній,
// то поверне цей видалений елемент

// якщо масив на якому викликають shift пустий, то метод поверне undefined

const shiftArr = ['tina', 'misha', 'zhabka'];   //  ['misha', 'zhabka']

const shiftedValue = shiftArr.shift();          // 'tina'

/*
__________________________________________________________________________________________
|                                                                                        |
|                         Array.prototype.unshift(item1, ...itemN)                       |
|________________________________________________________________________________________| */
let unshift;

// Додає один або більше елементів в початок масиву. Якщо виклик методу присвоєний змінній, то Повертає
// нову довжину масиву



const unshiftArr = ['tina'];       // ['misha', 'zhabka','tina', ]

const newLengthUnshift = unshiftArr.unshift('misha', 'zhabka');      // 3



/*
__________________________________________________________________________________________
|                                                                                        |
|                                 Array.prototype.keys()                                 |
|________________________________________________________________________________________| */
let keys;

// Повертає ітератор масиву, який тримає в собі ключи кожного індексу масиву

let keysArr = ['a', 'b', 'c'];
let iterator = keysArr.keys();

iterator.next(); // { value: 0, done: false }
iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: undefined, done: true }




/*
__________________________________________________________________________________________
|                                                                                        |
|                                 Array.prototype.values()                               |
|________________________________________________________________________________________| */
let values;

// Повертає новий обєкт ітератору масива, в якому знаходяться значення для кожного індексу в масиві

var valuesArr = ['w', 'y', 'k', 'o', 'p'];
var eArr = valuesArr.values();

for (let letter of eArr) {
//   console.log(letter);               // по черзі виведе всі букви
}

// або 


var valuesArr2 = ['w', 'y', 'k', 'o', 'p'];
var eArr2 = arr.values();
eArr2.next().value; // w
eArr2.next().value; // y
eArr2.next().value; // k
eArr2.next().value; // o
eArr2.next().value; // p



/*
__________________________________________________________________________________________
|                                                                                        |
|                                 Array.prototype.entries()                              |
|________________________________________________________________________________________| */
let entries;

// Повертає новий обєкт ітератора масиву, в якому знаходяться пари ключ/значення для кожного елементу
// масиву

var entriesArr = ['a', 'b', 'c'];
var eArr3 = entriesArr.entries();

eArr3.next().value; // [0, 'a']
eArr3.next().value; // [1, 'b']
eArr3.next().value; // [2, 'c']




/*
__________________________________________________________________________________________
|                                                                                        |
|                            Array.prototype.with(index, value)                          |
|________________________________________________________________________________________| */
let withh;

// Дозволяє змінити значення певного елементу масиву і повернути новий масив з зміненим значенням.
// Не змінює початковий масив


// Аргументи:
// ====    index - (обовязковий) -  індекс елементу, який треба змінити
// ====    value - (обовязковий) -  значення, на яке треба змінити

const withArr = ['empty', 'empty'];         //  ['empty', 'empty']

const withedArr = withArr.with(0, 'tina');  //  [ 'tina', 'empty' ]


of;                                     keys;
at;                                     values;
from;                                   entries;
withh;
isArray;                                filter;
                                        concat

push;                                   sort;
pop;                                    splice;
shift;                                  reverse;
unshift;
                                        
every;                                  toSorted;
some;                                   toSpliced;
                                        toReversed;
fill;                                   
flat;                                   join;
                                        slice;
forEach;                                
map;

reduce;
reduceRight;

find;
findIndex;
lastIndexOf;
indexOf;
includess;




console.log({foo:'bar'}.toString());