'use strict'

/*
__________________________________________________________________________________________
|                                                                                        |
|                          Object.create(protoObj, propsObj)                             |
|________________________________________________________________________________________| */




let create;
// Дозволяє створити новий обєкт з вказаним прототипом(1 аргумент). Другим аргументом вказуємо обєкт
// з додатковими властивостями і/або прапори властивостей

// Аргументи: 
// ===     protoObj - обєкт який стане прототипом для нового обєкту
// ===     propsObj - обєкт в якому можемо додати необхідні властивості для НОВОСТВОРЕНОГО обєкту

const human = {
    arms:2,         /*  ---->    базовий обєкт(прототип) */
    legs:'two'
};

// якщо в propsObj передати щось крім null і обєкту, то вилетить TYPEERROR

const misha = Object.create(human, {
    name: {                 /* ---> якщо додаємо нові ключі то обовязково вказувати прапори, якщо не вказати, то всі будуть виставлені в false */
        value: 'misha',    /* ---> значення властивості name */
        enumerable:true,   /* ---> чи буде властивість перелічуватись в циклах */
        writable: true,     /* ---> чи можна редкгувати властивість */
        configurable:true   /* ---> чи можна видаляти властивість і змінювати ці прапори */
    }
});

// тепер так як ми вказали прототим ми зможемо отримувати значення arms, legs з обєкту misha

misha.arms  /* ---->   2 */

const whaObj = Object.create(null, {     // [Object: null prototype] {}
    misha:{
        value:5
    }
} )




/*
__________________________________________________________________________________________
|                                                                                        |
|                          Object.assign(inititalObj, ...sources)                        |
|________________________________________________________________________________________| */
let assign

/* використовується для копіювання значень всіх власних перечисляємих властивостей(enumerable:true) в
цільовий обєкт */

// НЕ РОБИТЬ ГЛИБОКУ КОПІЮ

// успрадковані та неперечисляємі властивості не копіюються

// ...sources якщо передати null або undefined, то вони будуть проігноровані
// ...sources якщо передати примітиви, то вони обернуться в обєкти

// якщо по ходу копіювання ...sources десь в середині виникне помилка, то копіювання зупиниться на елементі з помилкою
// і не піде далі

const objectCar = {
    car:'sedan',
    year: 1970
};

const objectFerrari = {
    model:'ferrari',
    year: 1980               /* ------> якщо властивості повторяються, то властивість перезаписується наступним елементом в списку аргументів */
};

const unitedCarObj = Object.assign({}, objectCar, objectFerrari);     /* ----->  створює пустий обєкт і кладе в нього все наступне */


// Object.assign не копіює прапори властивостей. Всі будуть виставлені в true


unitedCarObj;     /* ----->     { car: 'sedan', year: 1980, model: 'ferrari' } */







/*
__________________________________________________________________________________________
|                                                                                        |
|                                 Object.preventExtencions(obj)                          |
|________________________________________________________________________________________| */
let preventExtensions;
// Робить неможливим додавання нових властивостей в цільовий обєкт. Проте їх можна видалити/редагувати.
// Можливість зміни прототипу цього обєкту нікуди не дінеться


// якщо переадити примітив, то поверне цей примітив
const natureEffects = {
    rain: true,
    snow:true,
    wind: true,
}

Object.preventExtensions(natureEffects);         /* ----> забороняємо додавати нові властивості */
natureEffects.heath = 15                         /* -----> з use strict буде TypeError, а без буде просто проігноровано */
natureEffects.wind = false                      /* ------> спрацює, адже змінювати можна */
delete natureEffects.rain;                      /* -----> також спрацює, адже видалення все же можливе */



// також можна перевірити обєкт чи можна його розширювати

const isExtensible = Object.isExtensible(natureEffects);      /* ----->    false,   не можна розширювати */








/*
__________________________________________________________________________________________
|                                                                                        |
|                                     Object.seal(obj)                                   |
|________________________________________________________________________________________| */

let seal;

// дозволяє запічатати обєкт, ми не зможемо додавати нові властивості,видаляти старі, проте залишиться можливість їх редагування
// Також всім властивостям всередині встановить прапор configurable: false
'use strict'
const games = {
    MkX: '10',
    Forza: '7,5',
    gta5: '9.5'
};


Object.seal(games);
games.legacy = '2';    /* -----> з use strict буде TypeError, а без буде просто проігноровано */
games.Forza = '9';      /* ------> спрацює, адже змінювати можна */
delete games.gta5;      /* -----> з use strict буде TypeError, а без буде просто проігноровано */



// також існує перевірка на запічатаний обєкт

const isSealed = Object.isSealed(games);           /* ------> true, так, обєкт запічатаний */






/*
__________________________________________________________________________________________
|                                                                                        |
|                                     Object.freeze(obj)                                 |
|________________________________________________________________________________________| */

let freeze;
// заморожує обєкт. Ми не зможемо редагувати існуючі властивості, додавати нові та видаляті існуючі
// встановлює прапори configurable: false, writable:false

'use strict';
const movies = {
    tor: 10,
    spiderMan: 8,
    blackHawck: 3,
};


Object.freeze(movies);

movies.tor = 9;                 /* -----> з use strict буде TypeError, а без буде просто проігноровано */
movies.LordOfTheRing = 10;      /* -----> з use strict буде TypeError, а без буде просто проігноровано */
delete movies.blackHawck;       /* -----> з use strict буде TypeError, а без буде просто проігноровано */

// існує перевірка на заморожений обєкт

const isFrozen = Object.isFrozen(movies)        /* ------> true, так, обєкт заморожений */







/*
__________________________________________________________________________________________
|                                                                                        |
|                                        Map(iterable)                                   |
|________________________________________________________________________________________| */
// в якості аргументу передається масив (такий як отримуємо від методу .entries)або нічого

let map
// map це структура данних, яка збрерігає пари ключ/значення, і памятає порядоr їх додавання.
// В якості ключів можуть використовуватись будь які значення.

/* Переваги:
=== будь який тип ключу
=== безпечний в використанні при наданні ключів і значень юзером
=== по дефолту не вміщує ніякі ключі та значення
=== гарантує порядок ключів/значень
=== з легкістю можна отримати кількість ключів
=== ітеративний
=== краще обробляє часте додавання/видалення властивостей */


const newMapObj = new Map();
const mishaSymbol = Symbol('misha')
// додавання властивості
newMapObj.set(() => {}, 'function key');
newMapObj.set({foo: 'bar'}, 'object key');
newMapObj.set(['foo', 'bar'], 'array key');
newMapObj.set(123, 'number key');
newMapObj.set('strange', 'string key');
newMapObj.set(Symbol('key'), 'symbol key');
newMapObj.set(Symbol('Тіна'));                          // в такому випадку ключем буде символ а значенням undefined
newMapObj.set(mishaSymbol, 'my name misha');            // щоб ми могли звертатись по символу, потрібно присвоїти його змінній, щоб мати на нього посилання       


// перевірка наявності властивості
newMapObj.has('strange');   // true


// отримання значення властивості
newMapObj.get(123);       // 'number key'

newMapObj.get(mishaSymbol); //  'my name misha'

// видалення властивості
newMapObj.delete(123);

// отримання розміру 
newMapObj.size  // 5 

// видалення всіх властивостей
newMapObj.clear()

// Map ітеративний, тому можна використовувати .forEach, for...of , а також такі методи як .keys, .values, .entries




/*
__________________________________________________________________________________________
|                                                                                        |
|                                    weakMap(iterable)                                   |
|________________________________________________________________________________________| */
let weakMap;
// в якості аргументу передається масив (такий як отримуємо від методу .entries)або нічого

/* 
В weakMaр в якості ключів можуть виступати ТІЛЬКИ обєкти, а в якості значень будь що. 
Особливістю являється те, що якщо на певний ключ ніде нема посилання окрім як в weakMap, то
ключ з значенням буде видалений збірником сміття */

/* weakMap не ітеративний, тому в ньому присутні тільки наступні методи:
=== WeakMap.prototype.delete()
=== WeakMap.prototype.get()
=== WeakMap.prototype.has()
=== WeakMap.prototype.set() */

const forWeakObj = {    // якщо видалити цей обєкт, то він видалиться і з weakMap
    foo: 'bar'
}
const newWeakMap = new WeakMap([[forWeakObj, 123]]);







/*
__________________________________________________________________________________________
|                                                                                        |
|                                       Set(iterable)                                    |
|________________________________________________________________________________________| */
// в якості аргументу передається масив (такий як отримуємо від методу .entries) або нічого
let set;

// дозволяє зберігатит УНІКАЛЬНІ значення будь якого типу, примітиви, або посилання на обєкти.
// Порядок елементів всередині = порядку вставки.


const setObj =  new Set([1,2,3,4,4,3,2,1]);
console.log(setObj);

/* присутні методи:
=== Set.prototype.set()
=== Set.prototype.get()
=== Set.prototype.has()
=== Set.prototype.delete()
=== Set.prototype.сlear()
=== Set.prototype.delete()
=== Set.prototype.size */

// Set ітеративний, тому можна використовувати .forEach, for...of , а також такі методи як .values, .keys(аналог .values),  .entries







/*
__________________________________________________________________________________________
|                                                                                        |
|                                   WeakSet(iterable)                                    |
|________________________________________________________________________________________| */

let weakSet;

// в якості аргументу передається масив (такий як отримуємо від методу .entries)або нічого


/* В weakSet в якості елементів можуть виступати ТІЛЬКИ обєкти(посилання на них)
Особливістю являється те, що якщо на певний ключ ніде нема посилання окрім як в weakSet, то
значення буде видалене збірником сміття  */

const weakArr1 = [1,4];
const weakArr2 = [15,45];
const newWeakSet = new WeakSet([weakArr1,weakArr2]);

/* WeakSet не ітеративний, тому в ньому присутні тільки наступні методи:
=== WeakMap.prototype.delete()
=== WeakMap.prototype.get()
=== WeakMap.prototype.has()
=== WeakMap.prototype.set() */




/*
__________________________________________________________________________________________
|                                                                                        |
|                                         WeakRef(obj)                                   |
|________________________________________________________________________________________| */
let weakRef;
// Дозволяє створити слабке посилання на обєкт

const fooObj = {
    name: 'Misha',
};

const bazObj = {
    sex:'male',
    additional: fooObj,     // тут у нас міцне посилання, тому fooObj не буде видалений збірником сміття
}




// щоб отримати значення name потрібно використати метод .deref()
const barObj = {
    name : new WeakRef(fooObj),  // створюється слабке посилання(якщо на fooObj більше ніде не посилаються, то fooObj буде видалено)
    age: 24,
};

barObj.name.deref()    // {name: 'Misha'}



/*
__________________________________________________________________________________________
|                                                                                        |
|                                         Symbol(descr)                                  |
|________________________________________________________________________________________| */

let symbol;


// Символ це унікальне значення, як створюється один раз, без можливості подальшого редагування і тд.
// Зручно використовувати для створення унікальних\прихованих властивостей обєктів

// створюєся методом виклику глобальної функції, аргументом приймає опис цього символу
// в аргумент можна передати що завгодно, воно буде зконвертоване в рядок
/* 
=== не перечисляються циклами, 
=== два символи з одинаковим desc !== один одному
=== для створення і отримання символів в глобальному реєстрі використовують Symbol.for() и Symbol.keyFor() */

const symbolsObject = {
    name: 'misha',
    [Symbol('age')]: 24,    
    [Symbol('sex')]: 'male',
};


// отримання всіх символів в обєкті
Object.getOwnPropertySymbols(symbolsObject) // отримаємо масив з символами

console.log(symbolsObject[Object.getOwnPropertySymbols(symbolsObject)[0]]);

// Методи:

/* 
Symbol.for(key)  ====  шукає існуючі символи по цьому ключу і повертає їх. Якщо не знаходить то
                        створюється новий символ для цього ключа в глобальному реєстрі */
let symbol1 = Symbol.for('symbol');
let symbol2 = Symbol.for('symbol');

let symbol3 = Symbol('some');
let symbol4 = Symbol('some');

symbol1 === symbol2 // true
symbol3 === symbol4 // false

// Symbol.keyFor(symbol) ==== дозволяє отримати ключ символа який знаходиться в ГЛОБАЛЬНОМУ РЕЄСТРІ

const symbol5 = Symbol.for('fifth symbol');
Symbol.keyFor(symbol5);                // fifth symbol

const symbol6 = Symbol('some descr');
Symbol.keyFor(symbol6);                 // undefined






/*
__________________________________________________________________________________________
|                                                                                        |
|                                 Object.is(value1, value2)                              |
|________________________________________________________________________________________| */
let is;

// Перевіряє чи являються два значення одинаковими ПО ЗНАЧЕННЮ. Тобто метод не приводить типи, 
// а тільки порівнює два значення.

Object.is(NaN, NaN) // true     якщо порівняти ось так: NaN === NaN ,   то буде false
Object.is(-0, +0) // false     якщо порівняти ось так: -0 === +0 ,   то буде true
console.log(Object.is({foo:'bar'}, {foo: 'bar'}));

/*
__________________________________________________________________________________________
|                                                                                        |
|                                  Object.keys(obj)                                      |
|________________________________________________________________________________________| */
let keys;

// Повертає масив всіх власних властивостей. Внаслідувані властивості не перераховує!!!

const colorsObj = {
    blue: 5,
    red:3,
};

const keysArr = Object.keys(colorsObj);     //  [ 'blue', 'red' ]






/*
__________________________________________________________________________________________
|                                                                                        |
|                                  Object.values(obj)                                    |
|________________________________________________________________________________________| */
let values;

// Повертає масив власних значень певного обєкту. Не лізе в прототипи.

const valuesObj = {
    a: 'some',
    b: 'any',
    c: 'what'
};

const valuesArr = Object.values(valuesObj);     //  [ 'some', 'any', 'what' ]





/*
__________________________________________________________________________________________
|                                                                                        |
|                                  Object.entries(obj)                                    |
|________________________________________________________________________________________| */
let entries;
// Повертає двомірний масив. з ключами та значеннями. Порядоок елементів в поверненому масиві
// не залежить від того в якому порядку стояли ключі і значення в obj.


const entrObj = {
    c: 'the best',
    a: 'good',
    124: 'dgsd',
    b:'worst',
};

const entrArr = Object.entries(entrObj);    // [['124', 'dgsd'], ['c', 'the best'], ['a', 'good'], ['b', 'worst'],]


create;
assign;

keys;
entries;
values;

preventExtensions;
seal;
freeze;

isExtensible;
isFrozen;
isSealed;

set;
map;

weakMap;
weakSet;
weakRef;

symbol;
is;



